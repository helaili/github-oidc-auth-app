[![Publish and Deploy](https://github.com/helaili/github-oidc-auth-app/actions/workflows/deploy.yml/badge.svg)](https://github.com/helaili/github-oidc-auth-app/actions/workflows/deploy.yml)

# github-oidc-auth-app

A GitHub App that generates a GitHub API scoped token from within an Actions workflow based on OIDC claims

# Overview
Oftentimes you need a GitHub Actions pipeline to use the GitHub API to perform some operations on another repository or organization. For example, you may want to get a container, or you may want to create a repository in a different organisation. In those cases, you need to use a GitHub API token that has the right scopes. The problem is that you cannot use the automatically provided GITHUB_TOKEN as it doesn't have enough permissions, and you don't want to use a personal access token because eithe. Those are tied to a specific humand user or to a machine account, and in both case it means generating, sharing, storing, renewing... a secret.

There is already a workaround for that with the [peter-murray/workflow-application-token-action](https://github.com/peter-murray/workflow-application-token-action), which will deliver a short lived token that will provide access to a foreign resource on GitHub. This solution is great as there is no runtime involved, it is just the configuration of a new GitHub App, but it requires to share a private key as an Actions secret with every repository that needs to use it. You have now way to audit the usage, and a key rotation will be painful. Last, a new GitHub App will be needed whenever a different scope is needed, and you have a limit of 100 apps per organization. Having said that, again, this is still the easiest and fastest solution to the problem of granting access to a foreign resource on GitHub.

Now if none of the above solutions fit your needs, this project provides a new approach. It relies on the ability to get [an OpenID Connect (OIDC) token](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect) from with an Actions workflow. This token generated by GitHub contains claims (repo name, environment, actor, ref, event...) that can't be faked. Therefore we can safely pass this over to this GitHub App which will verify the claims and generate a scoped, short-lived token that can be used to access the GitHub API. This token will provide a set of permission based on a configuration file which will allow to differentiate access based on the claims. With one app deployment, a workflow in repo X can have `write` access to the content of repo Foo, while a workflow in repo Y will have `admin` access to the org Bar.


# Architecture

```mermaid 
graph LR
  App(GitHub-OIDC-Auth App)
    
  subgraph Repository in Orgnisation 0
     Workflow(Workflow)
    Action(GitHub-OIDC-Auth action)
    Workflow-->Action
  end

  subgraph Installation 1 
    Inst1ID((Inst ID 1))
    Org1(Organisation 1)
    ConfigFile1(Configuration file 1)
    Org1-->ConfigFile1
  end

  subgraph Installation 2
    Inst2ID((Inst ID 2))
    Org2(Organisation 2)
    ConfigFile2(Configuration file 2)
    Org2-->ConfigFile2
  end


  Action -- Request token ==>App
  App -- Send scoped Token  -->Action
  App-->Org1
  App-->Org2
  
```
  
# Configuration

Those are the environment variables that can be used to configure the app:

`PORT`: **Required**. The port the process will listen to

`PRIVATE_KEY`: **Required**. The private key of the GitHub App as base64 encoded string

`APP_ID`: **Required**. The ID of the GitHub App

`CONFIG_REPO`: **Optional**. The name of the repository where the configuration file is stored. Default to `.github-private`

`CONFIG_FILE`: **Optional**. The name of the configuration file. Default to `oidc_entitlements.yml`

# Installation

- Create a GitHub App
- Generate a private key and store it as a secret in the repository where the app will be deployed
- Deploy the app to a server
- Configure the app with the environment variables
- Create a configuration file and store it in a repository according to the environment variables `CONFIG_REPO` and `CONFIG_FILE`
- Install the app in the organisations that will need to be accessed by the workflows
- Configure the workflows to use the app
